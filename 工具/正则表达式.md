# 正则表达式基础

## 基础知识

1. 方括号`[ ]`只能匹配一个字符，称为：字符类 或 字符簇。
    其中连字号`-`在`[ ]`中使用时表示一个字符的范围。

  Example：

  ```json
  [a-z]      // 匹配所有的小写字母
  [A-Z]      // 匹配所有的大写字母
  [a-zA-Z]   // 匹配所有的字母
  [0-9]      // 匹配所有的数字
  [0-9\.\-]      // 匹配所有的数字、句号、减号
  [ \n\f\r\t\v]  // 匹配所有的空白字符(空格、换行符、换页符、回车符、水平制表符、垂直制表符)
  ```

1.  `^`除了表示字符串的开头，还有另外一个含义，即当在一组方括号里使用`^`时，它表示”非”或”排除”的意思，常常用来剔除某个字符。

  Example：

  ```json
  [^a-z]       // 匹配除了小写字母以外的所有字符
  [^\\\/\^]    // 匹配除了\ / ^之外的所有字符
  [^\”\’]      // 匹配除了双引号和单引号之外的所有字符
  ```

1. 限定符
  花括号`{}`跟在字符或字符簇后面，用来确定前面的内容重复出现的次数，称为限定符。
      `{3}`     表示：前面的字符或字符簇只出现3次;
      `{3,}`       表示：前面的字符或字符簇出现3次或更多次;
      `{3,5}`     表示：前面的字符或字符簇出现至少3次，至多5次;
  除了`{}`，还有其他的限定符，如:
  `*`：重复0次或多次，等价于：`{0,}`
  `+`：重复1次或多次，等价于：`{1,}`
  `?`：重复0次或1次，等价于：`{0,1}`
  `|`：指明两项之间的一个选择，要匹配`|`，请使用`\|` 

  Example：

  ```cpp
  ^[0-9]{1,}$           // 匹配所有的正数
  ^[0-9]+$              // +与{1,}相等，表示前面的内容可以是1个或多个
  ^\-{0,1}[0-9]{1,}$    // 匹配所有的整数
  ^\-?[0-9]+$           
  ^\-{0,1}[0-9]{0,}\.{0,1}[0-9]{0,}$  // 匹配所有小数的正则
  ^\-?[0-9]{0,}\.?[0-9]{0,}$    // ?与{0,1}相等，表示前面的内容是可选的
  ^\-?[0-9]*\.?[0-9]*$          // *与{0,}相等，表示前面的内容可以是0个或多个
  ```

  > 如果在限定符`*、+、?、{n}、{n,}、{n,m}`之后再添加一个字符`?`，则表示尽可能少地重复字符`?`之前的限定符的重复次数，这种匹配方式称为懒惰匹配。与之相对应的是贪婪匹配，即仅仅使用单个限定符`*、+、?、{n}、{n,}、{n,m}`的匹配。

1. 元字符
  - 匹配位置的元字符
      `^`  匹配行的开始位置
      `$`  匹配行的结束位置
      `\b` 匹配单词的开始或结束位置
  - 匹配字符的元字符
      `.`  匹配除换行符之外的任意字符
      `\d`    匹配一个数字字符，等价于`[0-9]`
      `\D`    匹配一个非数字字符，等价于`[^0-9]`
      `\w`    匹配任何单词字符(包括字母、数字、下划线)，等价于`[a-zA-Z0-9_]`
      `\W`    匹配任何非单词字符，等价于`[^a-zA-Z0-9_]`
      `\s`      匹配任何空白字符，包括空格、换行符、换页符、回车符、水平制表符、垂直制表符，等价于`[ \n\f\r\t\v]`
      `\S`    匹配任何非空白字符，即不包含空格、换行符、换页符、回车符、水平制表符、垂直制表符，等价于`[^ \n\f\r\t\v]`
      `\b`    匹配一个单词边界，也就是指单词和空格间的位置。 例如：er\b可以匹配”never”中的”er”，但不能匹配”verb”中的”er"
      `\B`    匹配非单词边界。 例如：`er\B`可以匹配”verb”中的”er”，但不能匹配”never”中的”er”

  Example：

  ```ruby
  ^.{3}$            只能输入长度为3的字符
  ^[a-zA-Z0-9]+$    只能输入由数字、字母组成的字符串
  ^\w+$             只能输入由数字、字母、下划线三种单词字符组成的字符串
  (\w)\1     匹配两个重叠出现的字符，其中\1表示对所获取匹配的引用。
       例如： “aabbc11ads”，匹配结果为三组”aa”、“bb”、“11”的match。
       在第一次匹配过程中，\1就表示了对匹配字符a的引用，因此对连续出现的a匹配成功；
       若改为(\w)\1\1时，则可匹配连续出现三次的字符，如”aaabccc2sa”中的”aaa”和“ccc”。
  ```

## "？"的几种用法
 * "?"元字符规定其前导对象必须在目标对象中连续出现零次或一次。
 * 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串"oooo"，"o+?"将匹配单个"o"，而"o+"将匹配所有"o"。
 * (?:pattern) ——匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符"(|)"来组合一个模式的各个部分是很有用。例如"industr(?:y|ies)"就是一个比"industry|industries"更简略的表达式。
 * (?=pattern)——正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，"Windows(?=95|98|NT|2000)"能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
 * (?!pattern)——正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如"Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
 * (?<=pattern)——反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，"(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。
 * (?<!pattern)——反向否定预查，与正向否定预查类拟，只是方向相反。例如"(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。
 * (?i)——该表达式右边的字符忽略大小写
 * (?-i)——该表达式右边的字符区分大小写
 * (?i:x)——x 忽略大小写
 * (?-i:x)——x 区分大小写
 * ？和懒惰匹配——尽可能少的匹配，例如：源字符串str="dxxddxxd"中，d\w*?会匹配 dx,而d\w*?d会匹配 dxxd


### 正向与反向预查

```bash
"Swift1 Swift2 Swift3Swift4Swift4Swift4"
```

`(Swift4)`       匹配Swift4并获取这一匹配，然后存储供以后使用；

`(Swift4)\1`   匹配Swift4Swift4，其中`\1`即表示使用了存储的匹配(存储的第一个匹配)，相当于匹配两次Swift4；

`(Swift3)(Swift4)\2`      匹配Swift3Swift4Swift4，其中`\2`即表示使用了存储的第二个匹配，即Swift4(当然第一个匹配为：Swift3)；

`(?:Swift3)(Swift4)\1`   匹配Swift3Swift4Swift4，与`(Swift3)(Swift4)\2`相同；
由于在小括号中使用了`?:`，所以第一个匹配(Swift3)没有被存储，只存储了后面的第二个匹配(Swift4)；
若写成`(?:Swift3)(Swift4)\2`，则正则表达式错误，因为没有存储第二个匹配；
其中`?:`的作用是匹配Swift3模式字符串，但不会存储该匹配。

`Swift(?=4)`      匹配右边紧跟着4的Swift；
其中`(?=)`称为：正向预查匹配，`(?=4)`表示先看看有没有4，如果有，则把4左边的Swift匹配出来；如果没有，则继续向右查看，这个过程就是正向预查匹配。

> `(?=expression)`可理解为：匹配字符串expression前面的位置。

`Swift(?!4)`     匹配右边不跟着4的Swift；
其中`(?!)`称为：正向预查不匹配，`(?!4)`表示先看看有没有4，如果没有，也即不等于4的情况，则把左边的Swift匹配出来；如果有，则继续向右查看，这个过程就是正向预查不匹配。

> `(?!expression)`可理解为：匹配后面不是字符串expression的位置。

`(?<=4)Swift`    匹配左边紧跟着4的Swift，即第五个Swift单词，索引为26到30的字符；
其中`(?<=)`称为：反向预查匹配，`(?<=4)`表示先看看有没有4，如果有，则把4右边的Swift匹配出来；如果没有，则继续向右查看，这个过程就是反向预查匹配。

> `(?<=expression)`可理解为：匹配字符串expression后面的位置。

`(?<!4)Swift` 匹配左边不跟着4的Swift，即第1、2、3、4个Swift单词；
其中`(?<!)`称为：反向预查不匹配，(?<!4)表示先看看有没有4，如果没有，也即不等于4的情况，则把右边的Swift匹配出来；如果有，则继续向右查看，这个过程就是反向预查不匹配。

> `(?<!expression)` 可理解为：匹配前面不是字符串expression的位置。


# 反向引用

### 分组

反向引用的使用是基于分组的，所以得先理解清楚正则中分组的概念。什么是分组？个人理解的分组是正则匹配的一个或者多个字符，通常像元字符\w，\d，\s只能匹配一个字符，或者 [ ] 范围的匹配也只是匹配一个字符。**但是当需要匹配重复的组的时候**，例字符串：“asd123asd123”，不使用分组的正则写法是

```
var str = "asd123asd123";
var reg = /[a-z]{3}[1-9]{3}/;
reg.test(str);   //true
```

这种写法不但违反计算机科学原理，程序猿看上去还觉得别扭（众所周知，重复的代码都习惯了封装），所以我所理解的分组，其实就是正则表达式中的一种 “封装” 而已。那么经过封装后，上面的写法可以改写为

```
var str = "asd123asd123";
var reg = /([a-z]{3}[1-9]{3})\1+/; 
reg.test(str); //true
```

但是正则中的“封装“有个特点，就是引用时，引用的并非分组里面的正则表达式，而是已经匹配成功的内容，从以下代码说明这点

```
var str = "asd123dsa321";
var reg = /([a-z]{3}[1-9]{3})\1+/; 
reg.test(str); // false, \1引用匹配的是已经匹配成功的asd123
```

###  后向引用

其实在上面的例子中，已经使用到了正则的后向引用。先来看看后向引用的概念---------“使用小括号指定一个子表达式后，**匹配这个子表达式的文本**可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：以分组的左括号为标志，从左向右，第一个分组的组号为1，第二个为2，以此类推。后向引用用于重复搜索前面某个分组匹配的文本。”

从概念中可以看出，其大概意思是使用正则去匹配字符串的时候，由于字符串中可能出现重复匹配的字符。那么先定好规则，当最左边的分组规则（即括号内的规则匹配成功时，记录匹配成功的字符串，给其一个\1好让后面继续拿来使用），第二个给\2，第三个给\3......

```
var str = "asd123zxc";
var reg = /(asd)((1)(2)(3))(zxc)/;
reg.exec(str);   
// ["asd123zxc", "asd", "123", "1", "2", "3", "zxc", index: 0, input: "asd123zxc"]
//观察这里的数组可以发现，\0 代表要匹配的整体， \1 为第一个分组， 
// \2为第二个分组整体（（1）（2）（3））, \3 为第二个分组内的子分组（1）.......
```

这里面的重点是要理清分组中的嵌套关系。

后向引用还有另外一个用法，就是$1,$2,$3......

```
var str = "asd123asd123";
var reg = /([a-z]{3}[1-9]{3})/;
str.replace(reg,"--$1--");   //"--asd123--asd123"
```

# 正则表达式案例

## 一、校验数字的表达式

- 3位及以上数字 `(\d{3,})`    
- 以1开头的2位数  `(1[1-9])`    
- 非1开头的2位数  `([2-9]\d)`
- 除0、1、2、8、9之外的1位数  `([34567]{1})` 
- 数字：`^[0-9]*$`
- n位的数字：`^\d{n}$`
- 至少n位的数字`：^\d{n,}$`
- m-n位的数字：`^\d{m,n}$`
- 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
- 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(\.[0-9]{1,2})?$`
- 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})$`
- 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
- 有两位小数的正实数：`^[0-9]+(\.[0-9]{2})?$`
- 有1~3位小数的正实数：`^[0-9]+(\.[0-9]{1,3})?$`
- 非零的正整数：`^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$`
- 非零的负整数：`^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$`
- 非负整数：`^\d+$ 或 ^[1-9]\d*|0$`
- 非正整数：`^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$`
- 非负浮点数：`^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
- 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
- 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
- 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
- 浮点数：`^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

------

## 校验字符的表达式

- 汉字：`^[\u4e00-\u9fa5]{0,}$`
- 英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`
- 长度为3-20的所有字符：`^.{3,20}$`
- 由26个英文字母组成的字符串：`^[A-Za-z]+$`
- 由26个大写英文字母组成的字符串：`^[A-Z]+$`
- 由26个小写英文字母组成的字符串：`^[a-z]+$`
- 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
- 由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}$`
- 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
- 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
- 可以输入含有^%&',;=?$\"等字符：`[^%&',;=?$\x22]+`
- 禁止输入含有~的字符：`[^~\x22]+`

------

## 三、特殊需求表达式

- Email地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`
- 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?`
- InternetURL：`[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
- 手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`
- 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
- 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
- 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: `((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)`
- 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
- 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`
- 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
- 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$`
- 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`
- 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
- 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
- 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
- 钱的输入格式：
  1. 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：`^[1-9][0-9]*$`
  2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`
  3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`
  4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
  5. 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：`^[0-9]+(.[0-9]{2})?$`
  6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`
  7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`
  8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`
  9. 精确到2位小数： `^[0-9]+(.[0-9]{2})?$`
  10. 最多保留2位小数，金额范围：0.01-10000.00。 `^((0\.\d?[1-9])|(0\.[1-9]0)|([1-9]\d{0,3}(\.\d{1,2})?)|(10000(\.0{1,2})?))$`
    正则表达式解释：
    `(0\.\d?[1-9])`            匹配：0.01~0.09 / 0.1~0.9 / 0.11~0.99
    `(0\.[1-9]0)`             匹配：0.10 / 0.20 / 0.30 / 0.40 / 0.50 / 0.60 / 0.70 / 0.80 / 0.90
    `([1-9]\d{0,3}(\.\d{1,2})?)` 匹配：1.00~9999.99
    `(10000(\.0{1,2})?)`        匹配：10000 或 10000.0 或 10000.00
  11.  备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
- xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$`
- 中文字符的正则表达式：`[\u4e00-\u9fa5]`
- 双字节字符：`[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))`
- 空白行的正则表达式：`\n\s*\r (可以用来删除空白行)`
- HTML标记的正则表达式：`<(\S*?)[^>]*>.*?|<.*? /> ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)`
- 腾讯QQ号：`[1-9][0-9]{4,} (腾讯QQ号从10000开始)`
- 中国邮政编码：`[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)`
- IP地址：`((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))`
- IP地址：`[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}`
- 密码
  - 强密码 (必须包含数字、小写字母和大写字母三种字符，即这三种字符的组合，且不能使用特殊字符，长度在8-16之间)
  ```ruby
  ^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,16}$
  ```
  - 强密码 (必须包含数字和字母两种字符，即数字和字母的组合，且不能使用特殊字符，长度在8-16之间)。
  ```ruby
  ^(?=.*[0-9])(?=.*[a-zA-Z])[0-9a-zA-Z]{8,16}$
  ```
  - 强密码 (必须包含数字、小写字母、大写字母和特殊字符四种字符，即这四种字符的组合，其中特殊字符为除数字、小写字母、大写字母以外的其他字符，长度在8-16之间)。
  ```ruby
  ^(?:(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[^0-9a-zA-Z])).{8,16}$
  ```
- 匹配以两个相同字母结尾的单词，如：zoo、success、all等。
  ```css
  \b[a-zA-Z]*([a-zA-Z])\1\b
  ```
- 正整数中剔除`0、1、2、8、9、10`。
  ```ruby
  ^(\d{3,})|(1[1-9])|([2-9]\d)|([34567]{1})$
  ```
  正则表达式解释：
  `(\d{3,})`    匹配：3位及以上数字
  `(1[1-9])`    匹配：以1开头的2位数
  `([2-9]\d)`   匹配：非1开头的2位数
  `([34567]{1})` 匹配：除0、1、2、8、9之外的1位数

# 参考

1. [Java 正则表达式](https://www.runoob.com/java/java-regular-expressions.html)
2. [正则表达式 - 语法](https://www.runoob.com/regexp/regexp-syntax.html)
3. Regex 正则表达式中几个符号([ ] ^ {} ?: ?= ?!)的概念 . https://www.jianshu.com/p/9c4979a3b7e4
4. 正则表达式——“？”的几种用法 https://blog.csdn.net/qq_37683835/article/details/88601721